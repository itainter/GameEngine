#include "forward_base.h"

#define PCF_LEVEL 3

Texture2D<float> gShadowMapTexture : register(t0);

SamplerState gShadowMapSampler : ShadowMapSampler
{
    Texture = <gShadowMapTexture>;
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

cbuffer LightBuffer : register(b0)
{
    float3 gLightDir : LIGHT_DIR;
};

float PCF(float2 coord, uint level, float bias, float lightDepthValue)
{
    uint width, height;
    gShadowMapTexture.GetDimensions(width, height);

    float texelWidth = 1.0f / width;
    float texelHeight = 1.0f / height;

    float shadowValue = 0.0f;
    for (int x = -level; x < level; ++x)
    {
        for (int y = -level; y < level; ++y)
        {
            float pcfDepth = gShadowMapTexture.Sample(gShadowMapSampler, coord + float2(x, y) * float2(texelWidth, texelHeight)).x;
            shadowValue += (lightDepthValue - bias) > pcfDepth ? 1.0f : 0.0f;
        }
    }
    shadowValue /= (level * 2 + 1) * (level * 2 + 1);
    return shadowValue;
}

float4 ForwardBase_PS(ForwardBase_VertexAttr input) : SV_Target
{
    float lightIntensity;
    float ambientStrength = 0.7f;
    float4 color = float4(0.3f, 0.3f, 0.3f, 1.0f);

    float2 orthoTexCoord;
    orthoTexCoord.x =  input.lightViewPosition.x / input.lightViewPosition.w / 2.0f + 0.5f;
    orthoTexCoord.y = -input.lightViewPosition.y / input.lightViewPosition.w / 2.0f + 0.5f;

    if((saturate(orthoTexCoord.x) == orthoTexCoord.x) && (saturate(orthoTexCoord.y) == orthoTexCoord.y))
    {
        lightIntensity = saturate(dot(input.normal, -gLightDir));
        float bias = max(0.05 * (1.0f - lightIntensity), 0.005f);
        float lightDepthValue = input.lightViewPosition.z;

        if(lightIntensity > 0.0f)
        {
            float shadowValue = PCF(orthoTexCoord, PCF_LEVEL, bias, lightDepthValue);
            color += (float4(0.5f, 0.5f, 0.5f, 1.0f) * lightIntensity * (1.0f - shadowValue));
            color = saturate(color);
        }
    }

    return color;
}