#include "forward_shading.h"

Texture2D<float> gScreenSpaceShadowTexture : register(t0);
Texture2D<float4> gBaseColorTexture : register(t1);
Texture2D<float4> gOcclusionTexture : register(t2);
Texture2D<float4> gMetallicRoughnessTexture : register(t3);

SamplerState gLinearSampler : LinearSampler
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
};

cbuffer LightBuffer : register(b0)
{
    float3 gLightDir : LIGHT_DIR;
};

cbuffer CameraBuffer : register(b1)
{
    float3 gCameraDir : CAMERA_DIR;
};

float4 ForwardShading_PS(ForwardShading_VertexAttr input) : SV_Target
{
    float3 color = float3(0.0f, 0.0f, 0.0f);
    float2 coord = 0.5f * float2(input.pos.x ,-input.pos.y) / input.pos.w + 0.5f;

    float4 sssVal = gScreenSpaceShadowTexture.Sample(gLinearSampler, coord);
    float4 baseColor = gBaseColorTexture.Sample(gLinearSampler, input.texcoord);
    float occlusion = gOcclusionTexture.Sample(gLinearSampler, input.texcoord).x;
    float4 metallicRoughness = gMetallicRoughnessTexture.Sample(gLinearSampler, input.texcoord);

    float3 lightColor = float3(1.0f, 1.0f, 1.0f);

    float3 diffuse = lightColor * saturate(dot(-gLightDir, input.normal));
    float3 h = -normalize(gLightDir + gCameraDir);
    float specFactor = 16.0f;
    float3 spec = lightColor * pow(max(dot(input.normal, h), 0), 1.0f / metallicRoughness.y);

    color += (0.2 + (diffuse + spec) * sssVal) * baseColor * occlusion;
    color = saturate(color);

    return float4(color, 1.0f);
}