#include "forward_base.h"

Texture2D<float> gShadowMapTexture : register(t0);

SamplerState gSampleTypeClamp : SampleTypeClamp
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

cbuffer LightBuffer : register(b0)
{
    float3 gLightDir : LIGHT_DIR;
};

float4 ForwardBase_PS(ForwardBase_VertexAttr input) : SV_Target
{
    float bias = 0.001f;
    float lightIntensity;
    float ambientStrength = 0.7f;
    float4 color = float4(0.3f, 0.3f, 0.3f, 1.0f);

    float2 orthoTexCoord;
    orthoTexCoord.x =  input.lightViewPosition.x / input.lightViewPosition.w / 2.0f + 0.5f;
    orthoTexCoord.y = -input.lightViewPosition.y / input.lightViewPosition.w / 2.0f + 0.5f;
    float lightDepthValue = input.lightViewPosition.z;

    float depthValue = gShadowMapTexture.Sample(gSampleTypeClamp, orthoTexCoord).x;

    if((saturate(orthoTexCoord.x) == orthoTexCoord.x) && (saturate(orthoTexCoord.y) == orthoTexCoord.y) && (lightDepthValue > 0))
    {
        if (lightDepthValue < depthValue + bias)
        {
            lightIntensity = saturate(dot(input.normal, -gLightDir));
            if(lightIntensity > 0.0f)
            {
                color += (float4(1.0f, 1.0f, 1.0f, 1.0f) * lightIntensity);
                color = saturate(color);
            }
            //color = float4(1.0f, 0.0f, 0.0f, 1.0f);
        }
        else
        {
            color = float4(0.0f, 1.0f, 0.0f, 1.0f);
        }
    }
    else
        color = float4(0.0f, 0.0f, 1.0f, 1.0f);

    return color;
}